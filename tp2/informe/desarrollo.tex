\begin{section}{Desarrollo}
	\begin{subsection}{Explicación}
		\begin{subsubsection}{Introducción al problema}
			La guerra lineal consiste en dos naves situadas en el hiperespacio de $n$ dimensiones con el objetivo de desintegrarse mutuamente mediante disparos de cañones $Warp$.\\
			
			Cada turno del combate consiste en lo siguiente:
			\begin{enumerate}
			\item Nos proveen la matriz $A'$ usada por el oponente para atacarnos y el punto $d'$ donde impactó el proyectil. Con esa información debemos intentar descubrir la posición $y$ donde se encuentra situada la nave enemiga, es decir, resolver el sistema $A'y=d'$.
					
			\item Tenemos la posición a la que pretendemos disparar ($d$) tenemos que conseguir una matriz $A$ tal que $Ax=d$ donde $x$ es nuestra posición.
			\end{enumerate}
		\end{subsubsection}
		\begin{subsubsection}{Estrategia}
			En cada turno nuestra estrategia consiste en lo siguiente:
			
			\begin{enumerate}
			\item Para resolver el sistema $A'y=d'$ decicimos usar métodos directos de resolución de sistemas de ecuaciones lineales.
				\begin{itemize}
					\item \underline{Opción 1:} Buscamos la matriz inversa de A' (existe porque es parte de las reglas de la batalla) mediante el método de eliminación Gaussiana. Es decir, efectuamos a la matriz A' distintas trasformaciones lineales hasta convertirla en la matriz identidad. Al mismo tiempo hacemos dichas trasformaciones a la matriz identidad quedando en esta la inversa de A'.
					Las transformaciones consisten en triangular superior e inferiormente A' y poner $unos$ en la diagonal.
					Una vez que conocemos la inversa ($A'^{-1}$) podemos hallar la posición buscada de la siguiente manera: $y=A'^{-1}*d'$.\\
					
					\item \underline{Opción 2:} Hallamos la factorización $LU$ de $A'$ (si no existe, conseguimos $PLU$). Resolvemos el sistema $LUy=d'$. LLamamos $Ux=z$ y resolvemos usando sustitución hacia adelante el sistema $Lz=d'$. Una vez que conocemos $z$ obtenemos $x$ tal que $Ux=z$ utilizando sustitución en reversa. (Con $PLU$ es el mismo procedimiento pero permutando $d'$ según $P$).\\
					
					Elegimos este método ya que las matrices son cuadradas y la implementación es sencilla.\\
					PONER MAS MOTIVOS COMO COMPLEJIDAD!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\
				\end{itemize}
			
				La exactitud con la que la calculemos la posición buscada $y$ depende del número de condición de la matriz $A'$, y de este calculo entre otras cosas depende la exactitud de nuestro disparo.\\
				
				Como creemos que el adversario va a utilizar matrices mal condicionadas para atacarnos, en cada turno estariamos calculando una posición errada de donde se encuentra. Por este motivo, decidimos usar la estrategia de disparar en el punto promedio de todos las posiciones calculadas hasta el momento de donde se situa. Esperamos de esta manera ir obteniendo cada vez mejores aproximaciones a donde se encuentra realmente.
			
			
			\item Para atacar necesitamos una matriz $A$ que al multiplicarla por nuestra posición resulte en un impacto en la posición deseada $d$. Es decir, necesitamos que $A$ cumpla $Ax=d$.
			
			Sea $n$ la dimensión de $A$.
			Dado que tenemos $n^2$ incognitas y $n$ ecuaciones, tenemos $n^2-n$ elementos de $A$ libres. Por este motivo, podemos elegir $A$ convenientemente y luego adaptarla (forzarla a cumplir $Ax=d$).			
			
			Como debemos proveer al adversario de la matriz $A$ que usemos para el ataque tenemos que idear una estrategia para que nuestra posición no sea descubierta en el siguiente turno. La estrategia consiste en generar matrices mal condicionadas que a su vez sean inversibles (esto último por reglamento).
			
			Para crear una matriz mal condicionada, generamos un único vector aleatorio de dimensión $n$ que resulta en las filas de dicha matriz. De esta manera tenemos una matriz cuyas filas son linealmente dependientes, por lo que la matriz no es inversible. Luego, sumamos a los elementos de la diagonal un $epsilon$ (QUE ELEGIMOS BLA BLA BLA BLA) obteniendo asi una matriz inversible y mal condicionada (JUSTIFICAR PORQUE).
			
			Por último, para forzarla a satisfacer el sistema elegimos una columna $j$ de $A$ tal que el $j-esimo$ elemento de $d$ sea distinto de $cero$ (COMO SABEMOS QUE NO ES EL NULO) (si es $cero$ los coeficientes de $A$ que pretendemos setear no tienen importancia) y consideramos incognitas sólo a los coeficientes de esa columna. Nos quedan así, $n$ incognitas y $n$ ecuaciones, por lo que podemos despejarlas y obtener la matriz final.
			\end{enumerate}
		\end{subsubsection}
	\end{subsection}
	\begin{subsection}{Implementación}
		En primer lugar el desarrollo consistio en implementar módulos para las operaciones entre Matrices y Vectores que fuesen necesarias para resolver sistemas lineales. Esto implicaba también implementar el algoritmo de factorización LU y el algoritmo de eliminación Gaussiana ambos con pivoteo parcial para resolver el sistema lineal.\\
		
		Escribimos el módulo \texttt{Matrix} que implementa una matriz en $\mathbb{R}^{nxn}$ con las siguientes operaciones:\\
		
		\begin{tabular}{rl}
			\texttt{Eliminación Gaussiana} & Eliminacion Gaussiana con pivoteo parcial.\\
			\texttt{LU} & Factorización LU con pivoteo parcial.\\
			\texttt{Inversa} & Matriz inversa con el método de Gauss.\\
			\texttt{K} & Número de condición.\\
			\multicolumn{2}{l}{
				\texttt{Suma, Resta, Multiplicación, Multiplicación por escalar, traspuesta}
			}
		\end{tabular}\\
		
		Usamos pivoteo parcial tanto para la eliminación Gaussiana como para la factorización LU para reducir el error de redondeo en las operaciones.\\
		
		Además escribimos la clase \texttt{Vector} que implementa un vector en $\mathbb{R}^n$ con las operaciones básicas como \texttt{Suma, Resta,
		Producto Escalar, Producto Vectorial, Normas}, etc.\\
		
		\underline{NOTA:} Ambas clases heredan de una clase \texttt{MatrixBase} que implementa las funciones básicas como son la suma, resta, multiplicación, etc.\\
		
		Teniendo la base (matrices, vectores y las operaciones entre ellos) implementamos una clase para la resolución de sistemas de ecuciones lineales y una clase para elegir la matriz de ataque.\\
		
		El módulo \texttt{linearSystem} implementa las siguientes funciones:\\
		
		\begin{tabular}{rl}
			\texttt{Resolución por inversa} & consigue la inversa y hace la multiplicación.\\
			\texttt{Resolución por LU} & consigue LU (PLU) y despeja el sistema usando\\
									   & sustitución hacia adelante y sustitución reversa.\\
		\end{tabular}\\
		
		El módulo \texttt{warpCannon} implementa las siguientes funciones:\\
		
		\begin{tabular}{rl}
			\texttt{Atacar} & consigue la posición de impacto deseada y arma la matriz correspondiente.\\
		\end{tabular}\\
		
		Esta clase tiene un método privado que calcula la posición del enemigo.
		
		Nuestra primer idea fue hacer un promedio coordenada a coordenada dandole una prioridad distinta a cada vector (posición), dicha prioridad dependia del número de condición de la matriz que uso el oponente en ese turno. Es decir, $y$ tiene mayor prioridad que $z$ si y sólo si $K(A')<K(A)$ siendo $A'y=d'$ y $Az=d$.
		
		Para lograr esto, teniamos un $array$ de $tuplas$ donde la primer coordenada correspondia al vector y la segunda al número de condición de la matriz asociada.
		
		La idea finalmente implementada es una versión más simple (por cuestiones de tiempo), que sólo toma el promedio sin asignar prioridades. Igualmente quedo implementado con $tupla$ (ignorando la segunda coordenada).
	\end{subsection}
\end{section}
